from __future__ import annotations
import numpy as np
import pandas as pd
from dataclasses import dataclass
from typing import Optional
from dateutil.relativedelta import relativedelta
import statsmodels.api as sm
from pathlib import Path

# =========================================================
# 1. Load monthly returns (and synthetic generator if needed)
# =========================================================

def load_monthly_returns(root_dir: Path) -> dict[str, pd.Series]:
    out = {}
    for path in sorted(root_dir.glob("*_Monthly_Revenues.csv")):
        ticker = path.stem.replace("_Monthly_Revenues", "")
        df = pd.read_csv(path)
        df["date"] = pd.to_datetime(df[["year", "month"]].assign(day=1))
        df["return"] = pd.to_numeric(df["return"], errors="coerce")
        out[ticker] = df.set_index("date")["return"].sort_index()
    return out


def generate_synthetic_log_returns(n_years: int = 10,
                                   seed: int = 123) -> pd.Series:
    """
    Synthetic monthly log-return series with:
      - sinusoidal seasonal pattern (~±1%)
      - uniform noise in [-0.02, 0.02]
    Noise is generated by a hand-made LCG so that Python and R
    can produce identical series for the same seed.
    """
    n_months = 12 * n_years
    idx = pd.date_range("2000-01-01", periods=n_months, freq="MS")

    # seasonal pattern (~±1%)
    month = idx.month
    seasonal_pattern = 0.01 * np.sin(2 * np.pi * (month - 1) / 12.0)

    # custom LCG: x_{n+1} = (a*x_n) mod m, with m=2^31-1, a=16807
    m = 2**31 - 1
    a = 16807

    x = seed % m
    if x == 0:
        x = 1

    u = np.empty(n_months, dtype=float)
    for i in range(n_months):
        x = (a * x) % m
        u[i] = x / m

    # uniform noise in [-0.02, 0.02]
    noise = 0.04 * (u - 0.5)

    log_ret = seasonal_pattern + noise
    return pd.Series(log_ret, index=idx, name="log_return")


# =========================================================
# 2. EWMA volatility (RiskMetrics-style) – not used in table
# =========================================================

def ewma_sigma_next(log_returns: pd.Series,
                    lam: float = 0.97) -> float:
    """
    One-step-ahead EWMA volatility forecast sigma_{T+1}.

    Recursion:
        sigma_{t+1}^2 = lam * sigma_t^2 + (1 - lam) * r_t^2

    Initialise sigma_1^2 with the sample variance.
    """
    r = log_returns.dropna().to_numpy(dtype=float)
    if r.size == 0:
        return np.nan

    if r.size > 1:
        sigma2 = float(np.var(r, ddof=1))
    else:
        sigma2 = float(r[0] ** 2)

    for rt in r:
        sigma2 = lam * sigma2 + (1.0 - lam) * float(rt) ** 2

    return float(np.sqrt(max(sigma2, 0.0)))


# =========================================================
# 3. DVR: Dummy-Variable Regression (beta + p-value)
# =========================================================

@dataclass
class DVRResult:
    forecast: float      # alpha_hat + beta_hat (mean in target month)
    alpha_hat: float     # mean outside target month
    beta_hat: float      # difference: r_m - r_not_m (seasonal effect)
    se_beta: float       # standard error of dummy coefficient
    t_beta: float        # t-stat for dummy
    p_beta: float        # p-value for dummy
    significant_10: bool # True if p_beta < 0.10


def dvr_forecast(log_returns: pd.Series,
                 forecast_month: Optional[pd.Timestamp] = None,
                 alpha_level: float = 0.10) -> DVRResult:
    """
    Dummy-variable regression for a single calendar month m:

      r_t ~ alpha + beta * D_t
    """
    log_returns = log_returns.dropna()
    if log_returns.empty:
        return DVRResult(*(np.nan,) * 6, False)

    if forecast_month is None:
        last = log_returns.index[-1]
        forecast_month = last + relativedelta(months=1)
    target_month = forecast_month.month

    df = pd.DataFrame({"r": log_returns})
    df["D"] = (df.index.month == target_month).astype(float)

    X = sm.add_constant(df["D"])
    ols_res = sm.OLS(df["r"], X).fit()

    alpha_hat = float(ols_res.params["const"])
    beta_hat  = float(ols_res.params["D"])
    se_beta   = float(ols_res.bse["D"])
    t_beta    = float(ols_res.tvalues["D"])
    p_beta    = float(ols_res.pvalues["D"])

    forecast = alpha_hat + beta_hat
    significant = (p_beta < alpha_level)

    return DVRResult(forecast, alpha_hat, beta_hat, se_beta, t_beta, p_beta, significant)


# =========================================================
# 4. Scaling experiment: DVR beta only
# =========================================================

def run_dvr_scaling_experiment(
    c: float = 2.0,
    use_synthetic: bool = False,
    n_years: int = 10,
    seed: int = 123,
    ticker: str = "CC",
    start: str = "2005-01-01",
    end: str = "2014-12-01",
) -> pd.DataFrame:
    """
    Scaling experiment for a single contract (default: CC, 2005–2014) using DVR.

    - If use_synthetic is False, uses real simple returns from CSV.
    - If use_synthetic is True, uses a synthetic log-return series.
    - Compares DVR beta_hat for c = 1 vs c = c.
    """
    if use_synthetic:
        returns_base = generate_synthetic_log_returns(n_years=n_years, seed=seed)
    else:
        base = Path().resolve().parent.parent / "Complete Data"
        returns = load_monthly_returns(base / "All_Monthly_Log_Return_Data")
        returns_base = returns[ticker].loc[start:end]

    returns_scaled = c * returns_base

    N = len(returns_base)
    last_month = returns_base.index[-1].month
    target_month = 1 if last_month == 12 else last_month + 1
    forecast_month = returns_base.index[-1] + relativedelta(months=1)

    dvr_base   = dvr_forecast(returns_base,   forecast_month=forecast_month)
    dvr_scaled = dvr_forecast(returns_scaled, forecast_month=forecast_month)

    rows = [{
        "Model": "DVR",
        "Statistic": "beta",
        "Value c=1": dvr_base.beta_hat,
        f"Value c={c:g}": dvr_scaled.beta_hat,
        "p-value c=1": dvr_base.p_beta,
        f"p-value c={c:g}": dvr_scaled.p_beta,
    }]

    result = pd.DataFrame(rows)

    pd.set_option("display.float_format", lambda x: f"{x: .6g}")

    print(f"\n=== DVR scaling experiment (ticker {ticker}, c = {c}) ===\n")
    print(f"Series length: {N} months")
    print(f"Target calendar month (1=Jan,...,12=Dec): {target_month}\n")
    print(result.to_string(index=False))

    return result


# =========================================================
# 5. Run when executed as script
# =========================================================

if __name__ == "__main__":
    run_dvr_scaling_experiment(c=2.0, use_synthetic=False)
